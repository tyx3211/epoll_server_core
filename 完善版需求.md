## 完善版Web服务器需求文档

### 1. 项目总览

**目标**: 开发一个基于Linux C语言的、可作为库嵌入到其他应用中的轻量级、事件驱动的高性能HTTP服务器。

**核心技术栈**:
- **语言**: C
- **I/O模型**: `epoll` ET (边缘触发) 模式 + 非阻塞Socket
- **并发模型**: Reactor
- **协议**: HTTP/1.1

---

### 2. 功能需求

#### 2.1. HTTP协议处理
- **请求解析**:
  - **请求行**: 能够正确解析方法 (GET, POST), URI, 以及HTTP版本。
  - **请求头**: 逐行解析并存储键值对，特别是 `Host`, `Content-Type`, `Content-Length`, `Connection` 等。
  - **请求体**: 根据 `Content-Length` 准确读取请求体内容。
- **响应构建**:
  - **状态行**: 根据处理结果生成正确的状态码和状态描述 (e.g., `200 OK`, `404 Not Found`)。
  - **响应头**: 自动或手动设置必要的响应头，如 `Content-Type`, `Content-Length`, `Server`, `Date`, `Connection`。
- **连接管理**:
  - 支持 `Keep-Alive`，允许单个TCP连接处理多个HTTP请求，并正确处理TCP流中的请求粘包与分包问题。

#### 2.2. 静态资源服务
- **网站根目录**: 可通过配置文件指定，用于存放所有对外提供访问的静态文件。
- **默认页面**: 当请求URI为 `/` 时，自动返回根目录下的 `index.html`。
- **内容类型**: 根据请求文件的扩展名 (e.g., `.html`, `.css`, `.js`, `.jpg`, `.png`, `.ico`)，在响应头中设置正确的 `Content-Type`。
- **示例网站**:
  - **首页**: 一个简洁的欢迎页面 (`index.html`)。
  - **博客页面**: 一个包含文字、CSS样式、JS交互和图片的简单博客页面，以展示对不同类型文件的处理能力。

#### 2.3. 动态API与业务逻辑
- **API路由框架**:
  - 提供一个路由注册机制，允许开发者将特定的URL路径（如 `/api/login`）和HTTP方法（如 `POST`）绑定到自定义的C处理函数上。
- **安全认证示例**:
  - **接口**: 实现 `POST /api/login` 接口。
  - **逻辑**: 接口接收POST请求体中的用户名和密码（例如，`application/x-www-form-urlencoded` 格式），与一个简单的CSV文件 (`users.csv`) 中的记录进行比对，返回认证成功或失败的信息。

#### 2.4. 错误处理
- 为常见的客户端和服务器错误提供用户友好的HTML错误页面。
  - `400 Bad Request`: 请求解析失败。
  - `403 Forbidden`: 禁止访问。
  - `404 Not Found`: 请求的资源不存在。
  - `500 Internal Server Error`: 服务器内部逻辑错误。

---

### 3. 非功能性需求

#### 3.1. 项目结构
- **`Makefile`**: 用于自动化编译，生成库文件和示例程序，并提供清理功能。
- **`bin/`**: 存放使用本服务器库的示例可执行文件。
- **`lib/`**: 存放编译生成的静态库 (`.a`) 或动态库 (`.so`)。
- **`obj/`**: 存放编译过程中产生的中间目标文件 (`.o`)。
- **`src/`**: 存放所有 `.c` 和 `.h` 源代码文件。
- **`www/`** (或 `static/`): 存放所有静态网站资源。
- **`conf/`**: 存放配置文件，例如 `server.conf`。
- **`log/`**: 存放生成的日志文件。
- **`README.md`**: 提供项目简介、功能列表、编译方法、配置说明和使用示例。
- **`PPT文案.md`**: 用于准备答辩的思路和文案。

#### 3.2. 配置系统
- 通过 `conf/server.conf` 配置文件管理服务器行为，若配置文件不存在或未指定，则使用默认值。
- **可配置项**:
  - `ListenPort`: 监听的端口号 (e.g., 8080)。
  - `DocumentRoot`: 静态文件根目录 (e.g., `../www`)。
  - `LogPath`: 日志文件存放目录。
  - `LogLevel`: 系统日志的最低记录级别 (DEBUG, INFO, WARNING, ERROR)。
  - `LogTarget`: 日志输出目标 (stdout, file)。

#### 3.3. 日志系统
- **双日志系统**:
  - **访问日志 (`access.log`)**: 记录每一条HTTP请求的摘要信息，格式例如: `[时间] "请求方法 URI HTTP版本" 状态码 响应体大小 "User-Agent"`。
  - **系统日志 (`system.log`)**: 记录服务器的运行状态、调试信息和错误。
- **日志级别**:
  - `DEBUG`: 用于开发调试的详细信息。
  - `INFO`: 重要的运行时事件。
  - `WARNING`: 可能存在的问题或异常情况。
  - `ERROR`: 导致功能失败的严重错误。

#### 3.4. 编码与命名规范
- **结构体名**: `UpperCamelCase` (e.g., `HttpRequest`)。
- **函数名**: `lowerCamelCase` (e.g., `parseRequestLine`)。
- **变量名**: `lowerCamelCase` (e.g., `requestBuffer`)。
- **常量/枚举**: `UpperCamelCase` (e.g., `DefaultPort`)。
- **宏定义**: `UPPER_SNAKE_CASE` (e.g., `MAX_BUFFER_SIZE`)。

---

### 4. 核心架构设计

#### 4.1. 公开API与启动流程
- **库接口**: 服务器将作为一个库提供给开发者。核心启动函数为 `startServer(const char* configFilePath)`。
  - `configFilePath`: 配置文件路径。如果为 `NULL` 或空字符串，则使用内部默认配置。
- **启动过程**:
  1. 开发者在其应用程序的 `main` 函数中调用 `startServer()`。
  2. `startServer()` 内部负责解析配置文件（或使用默认值）。
  3. 初始化监听Socket、`epoll` 实例等所有服务器资源。
  4. 启动主事件循环（Reactor）。此函数通常会阻塞，直到服务器停止。
- **路由注册**:
  - 提供 `addRoute(const char* httpMethod, const char* path, RouteHandler handler)` 函数。
  - `handler` 是一个函数指针，类型为 `void (*RouteHandler)(HttpRequest* req, HttpResponse* res)`。
  - 开发者在调用 `startServer()` 之前，使用此函数注册所有自定义的API路由。

#### 4.2. 事件处理模型 (Reactor)
- 主线程进入无限循环，调用 `epoll_wait` 阻塞等待事件。
- **连接事件**: 如果是监听Socket就绪，调用 `accept` 接受新连接，将新的客户端Socket设置为非阻塞，并注册到 `epoll` 实例以监听读事件。
- **读写事件**: 如果是客户端Socket就绪，将其分发给对应的HTTP请求处理函数。

#### 4.3. 连接与数据处理
- 为每个客户端连接维护一个独立的上下文结构，包含读写缓冲区和状态机。
- **读数据**: 使用非阻塞 `read` 循环读取数据到读缓冲区，直到返回 `EAGAIN`。
- **请求处理**:
  1. 在读缓冲区中查找完整的HTTP请求（以 `\r\n\r\n` 结尾）。
  2. 如果找到，则调用HTTP解析模块进行解析。
  3. 根据解析结果（静态资源请求或API请求），调用相应逻辑。
  4. 生成HTTP响应并写入写缓冲区。
  5. 将该连接在 `epoll` 中的监听事件修改为“写事件”。
- **写数据**: 当连接的写事件就绪时，将写缓冲区的数据通过非阻塞 `write` 发送出去。全部发送完毕后，根据 `Connection` 头决定是继续监听读事件（Keep-Alive）还是关闭连接。
